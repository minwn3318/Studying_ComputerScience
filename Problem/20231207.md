# 20231207 - 목   (프로토타입 이해)
## 개요    
디자인 패턴 과제를 하고 있었다.    
GoF 디자인 패턴 중 생성패턴 2개, 구조패턴 1개, 행동패턴 1개를 조사하고 그것들로 구성한 프로젝트를 만드는 것이다.   
비록 gui 프로그래밍이라던가 css, javascript를 알고 있는 건 아니었지만, 오직 c++로 구성하라는 프로젝트였다.   
우리가 조사하기로 한 패턴은 다음 4개 였다.   
* 싱글턴
* 프로토타입
* 퍼사드
* 반복자

이 중에서 내가 프로토타입에 팩토리 메서드 패턴이 추가된 부분하고, 퍼사드, 반복자를 구현하여야 했다.   
프로토타입의 개요는 다음과 같았다.   
#### 기존의 것을 복제해서 생성해내는 것   
클래스의 복사 생성자와 매우 유사했다.   
구현 코드는 조사했을 때 다음과 같이 나왔다.  
   
```
// 프로토타입 클래스 - 가상화
class Prototype
{
  virtaul Prototype* clone() = 0;
};

// 프로토타입 상속받은 자식 클래스
class Protuct : public Prototype
{
  Prototype* clone()
  {
    return new Protuct();
  }
};

//프로토타입을 이용해 물품을 생산하는 팩토리 클래스
class Factory
{
  private :
    Prototype* product;
  publice :
    Factory()
    {
      product = new Protuct();
    }
    Prototype* createProduct()
    {
      product->clone();
    }

};
```

조사하고 메인에서 이를 검증하려고 했다. 그런데 문제가 발생했다.   

---------------   

## 문제인식   
### 해당 패턴에서는 복제하는 요소가 없다.   

protuct객체가 생성되기까지 과정은 다음과 같다.   

1. 팩토리 객체가 생성되어 생성자가 호출되면서, 팩토리 객체의 멤버변수에 product 객체가 할당된다.
2. 팩토리 객체의 함수 createProduct를 통해 현재 멤버변수에 할당되어 있는 객체에 따라 clone()함수를 호출한다.
3. clone함수는 지금 할당된 또다른 객체타입을 할당한다.

과정을 보면 복제하는 내용이 없다. 새로 생성한다만 있다. 기존에 있는 것에서 복제하는 것이 아니라, 기존의 것에서 또 새로 만드는 것이다.   

무언가 잘못된 것 같아. 프로토타입이 사용되는 이유를 찾아보았다.   

* 프로토타입은 새로 객체를 생성하는 것에 컴퓨터자원이 많이 들 때, 기존의 것을 복제해서 객체를 생성한다.
* 프로토타입의 장점은 객체가 생성될 때마다 초기화 할 필요가 없다는 점이다.

여기서 컴퓨터 자원이 무엇일까 생각해보았다.  

* 메모리 할당량
* 연산량

메모리 할당같은 경우, 객체가 런타임 때 생성되는 것이기에 많이 생성하는 것 아닌 이상 신경쓸 필요가 없다 생각했다.  
덧붙여서 만약 메모리 할당을 줄이려고 하는 거라면 얕은 복사처럼 주소값이 공유되어야 할텐데 그러면,   
하나를 수정하면 해당 타입의 객체가 전부 변하니 말이 안된다. 
그러면 연산량이 많이 든다는 거다. 즉 초기화 시 어떤 걸 계산하고 셋팅하는데에 시간이 많이 걸리는 것을 줄이는 거다.

--------------   
   
## 해결법   
### clone의 new 연산자 부분에 this*을 넣자!   

생성할 때 복제가 일어나야 하니 복사생성자가 필요할 것이다.    
클래스를 선언하면 컴파일러는 프로그래머가 따로 명시하지 않으면 기본 생성자와 기본 복사 생성자를 염두해둔다.   
따라서 포인터인 this가 실제로 가지고 있는 값은 this*를 넣어 복사를 하게 만든다.    

----------------   

## 의문점   
### 이러면 하나를 변경햇을 때 다른 것들도 변경되지 않아?   

해당 방식의 문제점은 컴파일러가 기본을 제공하는 복사 생성자 방식을 채택한 것이다.   
이러면 얕은 복사 방식으로 주소를 공유하게 되어 하나만 변경해도 전부가 바뀌게 된다.   

------------------
   
## 결론   
### 따라서 깊은 복사방식의 생성자를 따로 만들어두어야 한다.
