# 상속   

* 부모 클래스 : 원형이 되는 클래스
* 자식 클래스 : 부모 클래스의 멤버 변수나 멤버 함수에 접근할 수 있는 클래스
  
## 객체 생성에 따른 부모 클래스와 자식 클래스 관계
### 자식 클래스 객체를 자식 클래스 타입으로 선언하여 생성한 경우   
  부모 클래스의 객체를 생성하고, 자식 클래스의 객체를 생성한다.

* 자식 클래스 객체 생성시 메모리 할당 형태   
1. 부모 클래스 객체가 할당
2. 자식 클래스 객체가 할당   
2-1. (자식클래스가 부모 클래스의 함수에 오버라이딩 된 경우)
   * 부모 클래스 부분의 정의부분이 자식 클래스 내용으로 변경된다.
   * 타입이 자식 클래스가 된다.   
2-2. (자식 클래스가 부모 클래스 이외의 고유 함수나 변수가 있을 경우)
   * 부모 클래스 부분에서 고유 함수나 변수가 있는 부분이 추가된다.
   * 함수 오버라이딩이 있다면 자식 클래스 내용을 변경된다.
   * 타입이 자식 클래스가 된다.

> 오해해서는 안될 것이 부모 클래스 객체가 존재하고, 자식 클래스 객체를 생성하면 자식 클래스는 부모 클래스와 같은 공간을 쓰는 것이 아니다!!

* 특징 : 자식 클래스 타입 객체에서 부모 클래스의 변수나 함수에 접근할 수 있다.
> 왜냐하면 이미 자식클래스 객체에는 부모 클래스 객체가 존재하니까!!!

### 자식 클래스 객체를 부모 클래스 포인터 타입으로 선언하여 생성한 경우   

* 특징 : 부모 클래스 포인터 타입 변수는 어느 자식 클래스 객체에게 접근 할 수 있다.
> 왜냐하면 자식 클래스들은 전부 부모 클래스 객체를 가지고 있으니까!!!

* 주의점 :
  1. 자식 클래스에서 부모 클래스 이외의 고유 특징이 있는 경우, 해당 고유 특징에는 접근이 불가능 하다
     > 타입은 부모 클래스이니까 부모 클래스 안에서 선언, 정의된 것만 허용된다.
  2. 가상함수가 아닌 함수의 오버라이딩이 있다면, 실제로 가리키는 객체가 자식 객체여도 부모 클래스의 정의가 실행된다.
     > 정의내용은 컴파일시 할당되고 실제 값은 런타임시 할당된다. 그러니 프로그램은 가상 함수라고 명시하지 않으면 컴파일시 할당된 내용으로 실행한다.
     > 가상함수는 정의내용이 실제 값이 할당되고 난 후 정의하겠다는 의미가 된다. 런타임시 할당된다는 거다.
