# 문제 링크   
https://github.com/minwn3318/Studying_ComputerScience/blob/main/Algorithm/phonketmon/phonketmon.md   

# 문제인식   
1. 2마리를 어떻게 뽑아내야 할까?
2. 먼저 1마리를 어떻게 뽑아내야할까? <- 선택
   
# '2' 분석   
* 배열은 벡터로 되어있다.
  * 인덱스나 반복자를 사용할 수 있다.
* 함수에는 매개변수가 벡터 밖에 존재하지 않는다.
  * 길이를 정해줘야하는 인덱스보다는 벡터의 길이에 따라 알아서 순환하는 반복자가 더 적합하다
* 반복자에 *연산자를 이용해 요소를 추출할 수 있다.

# '2' 결과   
다음과 같이 코드를 작성하여 벡터안의 요소를 확인할 수 있다.   
```
#include <stdio.h>
#include <vector>
using namespace std;

vector<int> input = { 1,1,2,2 };

int main()
{
  vector<int>::iterator input_Iter = input.begin();
  printf("%x \n", *input_Iter);
  return 0'
}
```
**출력결과**   
```
1
```

--------------   

# 문제인식   
1. 2마리를 어떻게 뽑아내야 할까? <- 선택
2. 먼저 1마리를 어떻게 뽑아내야할까? (완료)

# 분석   
* 비교를 하기 위해서는 한마리를 먼저 뽑고, 그뒤에 나머지 폰켓몬들 중 한 마리를 선택해야 한다.
* 먼저 뽑은 한마리는 고정시키고, 나머지 폰켓몬들을 뽑은 것을 순차적으로 뽑고 비교한다.
* 비교는 모든 폰켓몬과 해야하기에, 맨앞의 한 마리와 나머지들의 비교가 끝났으면, 두번째 한 마리와 그 뒤의 나머지들과 비교해주어야 한다.

# '1' 결과   
하나를 고정시키고 순차적으로 나머지와 비교해야하고, 고정된 폰켓몬하고 비교가 끝나면 그 다음 폰켓몬하고 나머지와 비교를 해야하므로 이중반복문이 적절하다    
   
### 구상도   
```
for(비교 고정 폰켓몬 번호; 비교고정 폰켓몬 번호< 끝의 폰켓몬 번호; 비교 고정 폰켓몬 번호++)
{
  for(나머지 비교 폰켓몬 번호; 나머지 비교 폰켓몬 번호 < 끝의 폰켓몬 번호; 나머지 비교 폰켓몬 번호++)
  {

  }
}
```

-------------   

# 문제인식   
3. 반복자에서 요소의 순서가 되는 번호는 어떻게 추출하지?

# 분석   
* vector.begin()은 반복자 타입을 반환한다.
* 반복자에는 ++연산으로 해당 벡터에서 자신의 위치에서 앞뒤로 움직이는 것은 가능하지만, 2칸앞, 2칸 뒤 같은 건 못한다.
* 벡터에 순서로 나타낼 수 있는 것은 대표적으로 인덱스가 있다.
  * 그런데 각 데이터마다 메모리주소가 있고, 이것은 인덱스처럼 번호로 사용될 수 있다.
* 반복자에서 요소를 추출하고 요소에서 주소를 추출할 수 있다.

# '3' 결과   
다음과 같이 코드를 작성하여 순서 번호가 되는 메모리주소를 추출할 수 있다.   
```
#include <stdio.h>
#include <vector>
using namespace std;

vector<int> input = { 1,1,2,2 };

int main()
{
  ector<int>::iterator input_Iter = input.begin();
  printf("%x \n", &(*input_Iter));
  input_Iter++;
  printf("%x \n", &(*input_Iter));
  input_Iter++;
  printf("%x \n", &(*input_Iter));

  return 0;
}
```

### 출력결과   
```
2943a420
2943a424
2943a428
```
